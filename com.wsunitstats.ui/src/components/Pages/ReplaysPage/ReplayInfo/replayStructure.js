export class ReplayParseResult {
  error;
  players;
  teams;
  match;
  message;
  timeLine;
  timeLinePeriod;

  addError(error, message) {
    this.error = error;
    this.message = message;
    return this;
  }

  addSuccess(match, teams, players, timeLine, timeLinePeriod) {
    this.error = 0;
    this.match = match;
    this.teams = teams;
    this.players = players;
    this.timeLine = timeLine;
    this.timeLinePeriod = timeLinePeriod;
    return this;
  }
}

export class Match {
  startTime;
  duration;
  mode;
  winnerTeams;
  playersCount;
  factionsCount;
  region;
  gameVersion;
  matchSeed;
  isMatchmaking;
  creator;
  isDevMode;
  isComplete;
  isWonderWin;
  replayCode;
  isMapGen;
  isMapReleased;
  mapCode;
  mapSymmetry;
}

export class Team {
  id;
  factions;
  players;
  isWinner;
  isPlayerTeam;
  color;
}

export class Player {
  id;
  // assumption that palyer controls only one faction
  // if there will be more - restructuring and complication of data structures is required
  factionId;
  nickname;
  isNicknameAutogenerated;
  rating;
  team;
  group;
  survivalTime;
  isWinner;
  isDead;
  color;
  researches;
  isWonderBuilt;
  isWonderWin;
  lastAgeResearch;
  unitsCreated;
  unitsKilledByFaction;
  unitsKilledPlain;
  mvpScore;
  timeLine;

  researchOn = false;
  survivalOn = false;
  unitsCreatedOn = false;
  unitsKilledOn = false;
}

export class PlayerResearch {
  id;
  takenTime;
  researchContext;
}

export class PlayerUnitStat {
  id;
  number;
  points;
}

export class MatchType {
  id;
  type;

  constructor(id, type) {
    this.id = id;
    this.type = type;
  }

  static #values = new Map([
    [0, 'replayMatchTypeFFA'],
    [1, 'replayMatchTypeTeamMatch'],
    [2, 'replayMatchTypeArmageddon'],
    [3, 'replayMatchTypeSurvival'],
    [4, 'replayMatchTypeRank1'],
    [5, 'replayMatchTypeRank2'],
    [6, 'replayMatchTypeSandbox'],
    [7, 'replayMatchTypeTOW'],
    [8, 'replayMatchTypeCustom'],
    [9, 'replayMatchTypeMafia'],
    [255, 'replayMatchTypeUndef']
  ]);

  static fromId(id) {
    const actualId = MatchType.#values.has(id) ? id : 255;
    const type = MatchType.#values.get(actualId);
    return new MatchType(actualId, type);
  }
}

export class SymmetryType {
  id;
  type;

  constructor(id, type) {
    this.id = id;
    this.type = type;
  }

  static #values = new Map([
    [0, 'replaySymmetryTypeNo'],
    [1, 'replaySymmetryTypeVertical'],
    [2, 'replaySymmetryTypeVerticalFlipped'],
    [3, 'replaySymmetryTypeHorizontal'],
    [4, 'replaySymmetryTypeHorizontalFlipped'],
    [5, 'replaySymmetryTypeDiagonal'],
    [6, 'replaySymmetryTypeDiagonalReverse'],
    [7, 'replaySymmetryTypeRandom'],
  ]);

  static fromId(id) {
    const actualId = SymmetryType.#values.has(id) ? id : 0;
    const type = SymmetryType.#values.get(actualId);
    return new SymmetryType(actualId, type);
  }
}

// duplicates the structure defined in researchOptions.json file
export const EventTypes = [
  'researchTypeAgeTransition',
  'researchTypeEco',
  'researchTypePop',
  'researchTypeTerritory',
  'researchTypeCombat',
  'researchTypeUnit',
  //'researchTypeBuff', - not present for researches char
  'researchTypeWonderTransition',
  'researchTypeOther'
];